dependencies - bcryptjs cloudinary cookie-parser dotenv express express-fileupload jsonwebtoken mongoose nodemailer validator -D nodemon




config-db 
controller- 
middleware-bigpromise 
models-user zone post
routes- homeroute userroute problemroute
touch .env app.js index.js nodemon.json

cibis neta

-->creating basic express app in app.js
const express = require('express')
const app = express();

--> export app.js
module.exports = app;

-->responsible for starting application is index.js importing app into the index.js
-->importing app.js into the index.js
const app = require('./app')

-->creating a basic server
require('dotenv').config();
app.listen(process.env.PORT, ()=>{
    console.log(`server is running at port: ${process.env.PORT}`);
})

-->add require statement for process.env into the app.js also for just a precaution
require('dotenv').config();

--> creating controllers------creating new file into controller "homeController"
--> create a method home and export it
exports.home = (req, res) => {
    res.status(200).json({
        success: true,
        greeting: "hello from api",
    });
};

--> creating new routes ==> home.js
---> importing homecontroller into that and then specify route and function it should render
const express = require('express')
const { home } = require('../controllers/homeController')
const router = express.Router()

router.route('/').get(home)

module.exports = router {make sure about the export statement it should be "module.exports"}

-->after done all this we have to use it as a middleware into the app.js
---> first we bring all the routes into the app.js we dont bring controllers because it is imported into the route
// import all the routes here
const home = require('./routes/home')

// router middleware
app.use('/api/v1', home)
----> what is the point of doing and breaking all the structure into this way 

---> injecting docs and middleware
var morgan = require('morgan')
// morgan middleware
app.use(morgan('tiny'))
----> this will give the timing and the response time into the console
--> adding regular middlewares

// regular middlewares
app.use(express.json());
app.use(express.urlencoded({extended: true}))

// cookies and file middleware
const cookieParser = require('cookie-parser')
const fileupload = require('express-fileupload')
app.use(cookieParser());
app.use(fileupload());

// swagger related
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');
const swaggerDocument = YAML.load('./swagger.yaml');
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

-->also need to make one swagger.yaml file and nodemon.json file to autosave files and restart server

-->custom error handlers
NOT NECCESSARYYYY

--> big promise
--->create a middleware bigpromise
module.exports = func => (req, res, next) => 
    Promise.resolve(func(req, res, next)).catch(next);

----> import it into the homecontroller and then wrap up whole function into the bigpromise
exports.home = BigPromise(async (req, res) => {
    // const db = await something();
    res.status(200).json({
        success: true,
        greeting: "hello from api",
    });
});

--> creating user (basic setup of mongoose)
const mongoose = require('mongoose');
const validator = require('validator');

const userSchema = new mongoose.Schema({ ? your Schema ? });

module.exports = mongoose.model('User', userSchema)

--> encrypting password and saving it
first import libraries which will be necessary to encrypt password and then encrypt password before save
this will only encrypt password if it is modiefied otherwise it will not encrypt or touch password thing
//encrypt password before save
userSchema.pre('save', async function (next) {
    if(!this.isModified("password")){
        return next() ;
    }
    this.password = await bcrypt.hash(this.password, 10)
});

---> validating password
userSchema.methods.isValidatedPassword = async function(userSentPassword){
    return await bcrypt.compare(userSentPassword, this.password)
}

--> creating jwt token
userSchema.methods.getJwtToken = function() {
    return jwt.sign({id: this._id}, process.env.JWT_SECRET),{
        expiresIn: process.env.JWT_EXPIRY 
    }
}

--> forgot password and crypto hashing
//generating forgot password token (STRING)
userSchema.methods.getForgotPasswordToken = function () {
    //generating forgot password token 
    const forgotToken = crypto.randomBytes(20).toString("hex");

    //getting a hash - make sure you are getting hash to backend
    this.forgotPasswordToken = crypto.createHash("sh256").update(forgotToken).digest("hex");

    // time of token 
    this.forgotPasswordExpiry = Date.now() + 20 *60 * 1000;

    return forgotToken;
}


--> user routes and controller
